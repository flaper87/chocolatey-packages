<?xml version="1.0" encoding="utf-8"?>
<!-- Do not remove this test for UTF-8: if ??? doesn?t appear as greek uppercase omega letter enclosed in quotation marks, you should use an editor that supports UTF-8, not this one. -->
<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
  <metadata>
    <!-- Read this before publishing packages to chocolatey.org: https://github.com/chocolatey/chocolatey/wiki/CreatePackages -->
    <id>vault</id>
    <title>Vault</title>
    <version>1.1.1</version>
    <authors>Mitchell Hashimoto, HashiCorp</authors>
    <owners>James Toyer, Tim Collins</owners>
    <summary>Vault is a tool for securely accessing secrets</summary>
    <description>
      Vault is a tool for securely accessing secrets. A secret is anything that you want to tightly control access to, such as API keys, passwords, certificates, and more. Vault provides a unified interface to any secret, while providing tight access control and recording a detailed audit log.

      A modern system requires access to a multitude of secrets: database credentials, API keys for external services, credentials for service-oriented architecture communication, etc. Understanding who is accessing what secrets is already very difficult and platform-specific. Adding on key rolling, secure storage, and detailed audit logs is almost impossible without a custom solution. This is where Vault steps in.

      The key features of Vault are:

      * **Secure Secret Storage**: Arbitrary key/value secrets can be stored in Vault. Vault encrypts these secrets prior to writing them to persistent storage, so gaining access to the raw storage isn't enough to access your secrets. Vault can write to disk, [Consul](https://www.consul.io), and more.
      * **Dynamic Secrets**: Vault can generate secrets on-demand for some systems, such as AWS or SQL databases. For example, when an application needs to access an S3 bucket, it asks Vault for credentials, and Vault will generate an AWS keypair with valid permissions on demand. After creating these dynamic secrets, Vault will also automatically revoke them after the lease is up.
      * **Data Encryption**: Vault can encrypt and decrypt data without storing it. This allows security teams to define encryption parameters and developers to store encrypted data in a location such as SQL without having to design their own encryption methods.
      * **Leasing and Renewal**: All secrets in Vault have a _lease_ associated with it. At the end of the lease, Vault will automatically revoke that secret. Clients are able to renew leases via built-in renew APIs.
      * **Revocation**: Vault has built-in support for secret revocation. Vault can revoke not only single secrets, but a tree of secrets, for example all secrets read by a specific user, or all secrets of a particular type. Revocation assists in key rolling as well as locking down systems in the case of an intrusion.

      For more information, see the [introduction section](https://www.vaultproject.io/intro) of the Vault website.
    </description>
          <releaseNotes>
      ## 1.1.1 (April 11th, 2019)

      SECURITY:

       * Given: (a) performance replication is enabled; (b) performance standbys are
         in use on the performance replication secondary cluster; and (c) mount
         filters are in use, if a mount that was previously available to a secondary
         is updated to be filtered out, although the data would be removed from the
         secondary cluster, the in-memory cache of the data would not be purged on
         the performance standby nodes. As a result, the previously-available data
         could still be read from memory if it was ever read from disk, and if this
         included mount configuration data this could result in token or lease
         issuance. The issue is fixed in this release; in prior releases either an
         active node changeover (such as a step-down) or a restart of the standby
         nodes is sufficient to cause the performance standby nodes to clear their
         cache. A CVE is in the process of being issued; the number is
         CVE-2019-11075.
       * Roles in the JWT Auth backend using the OIDC login flow (i.e. role_type of
         “oidc”) were not enforcing bound_cidrs restrictions, if any were configured
         for the role. This issue did not affect roles of type “jwt”.

      CHANGES:

       * auth/jwt: Disallow logins of role_type "oidc" via the `/login` path [JWT-38]
       * core/acl:  New ordering defines which policy wins when there are multiple 
         inexact matches and at least one path contains `+`. `+*` is now illegal in
         policy paths. The previous behavior simply selected any matching
         segment-wildcard path that matched. [GH-6532]
       * replication: Due to technical limitations, mounting and unmounting was not
         previously possible from a performance secondary. These have been resolved,
         and these operations may now be run from a performance secondary.

      IMPROVEMENTS: 

       * agent: Allow AppRole auto-auth without a secret-id [GH-6324]
       * auth/gcp: Cache clients to improve performance and reduce open file usage
       * auth/jwt: Bounds claims validiation will now allow matching the received
         claims against a list of expected values [JWT-41] 
       * secret/gcp: Cache clients to improve performance and reduce open file usage
       * replication: Mounting/unmounting/remounting/mount-tuning is now supported
         from a performance secondary cluster
       * ui: Suport for authentication via the RADIUS auth method [GH-6488]
       * ui: Navigating away from secret list view will clear any page-specific
         filter that was applied [GH-6511]
       * ui: Improved the display when OIDC auth errors [GH-6553] 

      BUG FIXES: 

       * agent: Allow auto-auth to be used with caching without having to define any
         sinks [GH-6468]
       * agent: Disallow some nonsensical config file combinations [GH-6471]
       * auth/ldap: Fix CN check not working if CN was not all in uppercase [GH-6518]
       * auth/jwt: The CLI helper for OIDC logins will now open the browser to the correct
         URL when running on Windows [JWT-37]
       * auth/jwt: Fix OIDC login issue where configured TLS certs weren't being used [JWT-40]
       * auth/jwt: Fix an issue where the `oidc_scopes` parameter was not being included in
         the response to a role read request [JWT-35]
       * core: Fix seal migration case when migrating to Shamir and a seal block
         wasn't explicitly specified [GH-6455]
       * core: Fix unwrapping when using namespaced wrapping tokens [GH-6536]
       * core: Fix incorrect representation of required properties in OpenAPI output
         [GH-6490]
       * core: Fix deadlock that could happen when using the UI [GH-6560]
       * identity: Fix updating groups removing existing members [GH-6527]
       * identity: Properly invalidate group alias in performance secondary [GH-6564]
       * identity: Use namespace context when loading entities and groups to ensure
         merging of duplicate entries works properly [GH-6563]
       * replication: Fix performance standby election failure [GH-6561]
       * replication: Fix mount filter invalidation on performance standby nodes
       * replication: Fix license reloading on performance standby nodes
       * replication: Fix handling of control groups on performance standby nodes
       * replication: Fix some forwarding scenarios with request bodies using
         performance standby nodes [GH-6538]
       * secret/gcp: Fix roleset binding when using JSON [GCP-27]
       * secret/pki: Use `uri_sans` param in when not using CSR parameters [GH-6505]
       * storage/dynamodb: Fix a race condition possible in HA configurations that could
         leave the cluster without a leader [GH-6512]
       * ui: Fix an issue where in production builds OpenAPI model generation was
         failing, causing any form using it to render labels with missing fields [GH-6474]
       * ui: Fix issue nav-hiding when moving between namespaces [GH-6473]
       * ui: Secrets will always show in the nav regardless of access to cubbyhole [GH-6477]
       * ui: fix SSH OTP generation [GH-6540]
       * ui: add polyfill to load UI in IE11 [GH-6567]
       * ui: Fix issue where some elements would fail to work properly if using ACLs
         with segment-wildcard paths (`/+/` segments) [GH-6525]

      ## Previous Releases
      For more information on previous releases, check out the changelog on [GitHub](https://github.com/hashicorp/vault/blob/v0.10.0/CHANGELOG.md).
    </releaseNotes>
    <projectUrl>https://www.vaultproject.io/</projectUrl>
    <docsUrl>https://www.vaultproject.io/docs/index.html</docsUrl>
    <bugTrackerUrl>https://github.com/hashicorp/vault/issues</bugTrackerUrl>
    <projectSourceUrl>https://github.com/hashicorp/vault</projectSourceUrl>
    <packageSourceUrl>https://github.com/tico24/chocolatey-packages</packageSourceUrl>
    <tags>vault hashicorp</tags>
    <copyright>HashiCorp 2015-2019</copyright>
    <licenseUrl>https://github.com/hashicorp/vault/blob/master/LICENSE</licenseUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <!-- Important note about https://cdn.rawgit.com: Files are cached permanently after the first request. Use commit URLs when updating the icon. -->
    <iconUrl>https://cdn.rawgit.com/jamestoyer/chocolatey-packages/68bd9f48bdf960b40c3b1a590c7aac3f0fdfb59f/vault/icons/vault.png</iconUrl>
    <!--<dependencies>
      <dependency id="" version="" />
    </dependencies>-->
  </metadata>
  <files>
    <file src="tools\**" target="tools" />
  </files>
</package>
